# Guia Completo: Nova Arquitetura Modular - Ciclo de Upload da Carteirinha

## üìÅ Estrutura de Arquivos e Responsabilidades

```
server/services/document-extraction/
‚îú‚îÄ‚îÄ index.ts                           # üö™ PONTO DE ENTRADA
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ extraction-types.ts            # üìù DEFINI√á√ïES DE TIPOS
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ extraction-orchestrator.ts     # üéØ ORQUESTRADOR PRINCIPAL
‚îÇ   ‚îî‚îÄ‚îÄ ocr-engine.ts                  # üëÅÔ∏è ENGINE OCR (Google Vision)
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ text-preprocessor.ts           # üßπ LIMPEZA DE TEXTO
‚îÇ   ‚îî‚îÄ‚îÄ flow-debugger.ts               # üêõ SISTEMA DE DEBUG
‚îú‚îÄ‚îÄ detectors/
‚îÇ   ‚îú‚îÄ‚îÄ ans-detector.ts                # üîç DETECTOR DE C√ìDIGO ANS
‚îÇ   ‚îî‚îÄ‚îÄ operator-detector.ts           # üè• DETECTOR DE OPERADORA
‚îî‚îÄ‚îÄ extractors/
    ‚îú‚îÄ‚îÄ sulamerica-extractor.ts        # üí≥ EXTRATOR SUL AM√âRICA
    ‚îî‚îÄ‚îÄ bradesco-extractor.ts          # üí≥ EXTRATOR BRADESCO (base)
```

## üîÑ Ciclo Completo: Upload ‚Üí Resposta

### **PASSO 1: Upload Frontend**
```typescript
// client/src/components/patients/patient-form-dialog.tsx:450
const handleInsuranceCardFileSelected = (event) => {
  const file = event.target.files?.[0];
  if (file) {
    processInsuranceCardWithOCR(file); // ‚Üê Inicia o processo
  }
};
```

### **PASSO 2: Envio para API**
```typescript
// client/src/components/patients/patient-form-dialog.tsx:248-252
const formData = new FormData();
formData.append('document', file);
formData.append('documentType', 'insurance');

const result = await apiRequest("/api/process-document", "POST", formData);
```

### **PASSO 3: Entrada na API**
```typescript
// server/routes.ts:3308
app.post('/api/process-document', upload.single('document'), async (req, res) => {
  console.log('üÜï FOR√áANDO nova arquitetura modular para carteirinha...');
  
  // For√ßa uso da nova arquitetura
  const documentExtractionService = await import('./services/document-extraction/index.js');
  const result = await documentExtractionService.processDocument(imageBuffer);
});
```

---

## üìÇ **ARQUIVO POR ARQUIVO - O QUE CADA UM FAZ**

### **1. üö™ index.ts - PONTO DE ENTRADA**
```typescript
// server/services/document-extraction/index.ts
export async function processDocument(imageBuffer: Buffer): Promise<any> {
  console.log('üìã Processando carteirinha de plano de sa√∫de com nova arquitetura...');
  
  const orchestrator = new ExtractionOrchestrator();
  return await orchestrator.processDocument(imageBuffer);
}
```
**O QUE FAZ:**
- Exporta fun√ß√£o principal que routes.ts chama
- Cria inst√¢ncia do orquestrador
- Delega processamento para extraction-orchestrator.ts

---

### **2. üìù extraction-types.ts - DEFINI√á√ïES DE TIPOS**
```typescript
// server/services/document-extraction/types/extraction-types.ts
export interface ExtractedData {
  numeroCarteirinha?: string;
  nomeTitular?: string;
  dataNascimento?: string;
  cns?: string;
  plano?: string;
  operadora?: string;
}

export interface ExtractionResult {
  success: boolean;
  data: ExtractedData;
  confidence: any;
  method: any;
}
```
**O QUE FAZ:**
- Define estruturas de dados para toda a arquitetura
- Garante tipagem TypeScript consistente
- Especifica contratos entre m√≥dulos

---

### **3. üéØ extraction-orchestrator.ts - ORQUESTRADOR PRINCIPAL**
```typescript
// server/services/document-extraction/core/extraction-orchestrator.ts
export class ExtractionOrchestrator {
  private ocrEngine: GoogleVisionOCREngine;
  private sulAmericaExtractor: SulAmericaExtractor;

  async processDocument(imageBuffer: Buffer): Promise<ExtractionResult> {
    // PASSO 1: OCR
    const rawText = await this.ocrEngine.extractText(imageBuffer);
    
    // PASSO 2: Limpeza
    const cleanText = TextPreprocessor.cleanText(rawText);
    
    // PASSO 3: Detectar ANS
    const ansCode = ANSDetector.extractANSCode(cleanText);
    
    // PASSO 4: Detectar operadora
    const detectedOperator = OperatorDetector.detectOperator(cleanText);
    
    // PASSO 5: Delegar para extrator espec√≠fico
    const extractedData = await this.delegateToOperatorExtractor(
      detectedOperator, cleanText, ansCode
    );
    
    // PASSO 6: Retornar resultado formatado
    return { success: true, data: extractedData, confidence, method };
  }
}
```
**O QUE FAZ:**
- **COORDENA** todo o fluxo de extra√ß√£o
- **CHAMA** cada m√≥dulo na ordem correta
- **INTEGRA** resultados de diferentes extractors
- **CALCULA** confidence score final
- **RETORNA** dados estruturados para o frontend

---

### **4. üëÅÔ∏è ocr-engine.ts - ENGINE OCR**
```typescript
// server/services/document-extraction/core/ocr-engine.ts
export class GoogleVisionOCREngine {
  async extractText(imageBuffer: Buffer): Promise<string | null> {
    console.log('üîç Iniciando extra√ß√£o de texto com Google Vision API...');
    
    const vision = new ImageAnnotatorClient();
    const [result] = await vision.textDetection({ image: { content: imageBuffer } });
    
    const detections = result.textAnnotations || [];
    if (detections.length === 0) {
      console.log('‚ö†Ô∏è Nenhum texto detectado na imagem');
      return null;
    }

    return detections[0].description || null;
  }
}
```
**O QUE FAZ:**
- **CONVERTE** imagem em texto usando Google Vision API
- **DETECTA** todo texto presente na carteirinha
- **RETORNA** texto bruto para processamento posterior
- **TRATA** erros de OCR e imagens sem texto

---

### **5. üßπ text-preprocessor.ts - LIMPEZA DE TEXTO**
```typescript
// server/services/document-extraction/utils/text-preprocessor.ts
export class TextPreprocessor {
  static cleanText(text: string): string {
    console.log('üßπ Iniciando limpeza do texto OCR...');
    
    return text
      .replace(/[^\w\s\d\-\/\.\:]/g, ' ')  // Remove caracteres especiais
      .replace(/\s+/g, ' ')                // Normaliza espa√ßos
      .trim()                              // Remove espa√ßos das bordas
      .toUpperCase();                      // Padroniza mai√∫sculas
  }
}
```
**O QUE FAZ:**
- **LIMPA** texto bruto do OCR
- **REMOVE** caracteres que atrapalham detec√ß√£o
- **NORMALIZA** espa√ßamento e capitaliza√ß√£o
- **PREPARA** texto para padr√µes de regex

---

### **6. üîç ans-detector.ts - DETECTOR DE C√ìDIGO ANS**
```typescript
// server/services/document-extraction/detectors/ans-detector.ts
export class ANSDetector {
  static extractANSCode(text: string): string | null {
    console.log('üîç Buscando c√≥digo ANS no texto...');
    
    const patterns = [
      /ANS\s*-\s*N[¬∫O¬∞]?\s*(\d{2})\.(\d{3})-(\d{1})/,  // ANS - N¬∞ 00.624-6
      /ANS\s*-\s*N[¬∫O¬∞]?\s*(\d{6})(?!\d)/,             // ANS - N¬∞ 006246
      /ANS\s*:\s*(\d{5,7})(?!\d)/,                      // ANS: 006246
    ];

    for (const pattern of patterns) {
      const match = text.match(pattern);
      if (match) {
        return match[1] + (match[2] || '') + (match[3] || '');
      }
    }
    return null;
  }
}
```
**O QUE FAZ:**
- **PROCURA** c√≥digo ANS no texto limpo
- **TESTA** m√∫ltiplos padr√µes de formata√ß√£o
- **EXTRAI** n√∫mero de 6 d√≠gitos (ex: 006246)
- **IDENTIFICA** operadora de forma mais precisa que texto

---

### **7. üè• operator-detector.ts - DETECTOR DE OPERADORA**
```typescript
// server/services/document-extraction/detectors/operator-detector.ts
export class OperatorDetector {
  static detectOperator(text: string): string | null {
    console.log('üîç Iniciando detec√ß√£o de operadora...');
    
    // M√âTODO 1: Por c√≥digo ANS (mais preciso)
    const ansCode = ANSDetector.extractANSCode(text);
    if (ansCode) {
      const operatorByANS = this.getOperatorByANS(ansCode);
      if (operatorByANS) {
        console.log(`‚úÖ Operadora detectada via ANS ${ansCode}: ${operatorByANS}`);
        return operatorByANS;
      }
    }

    // M√âTODO 2: Por padr√µes de texto
    const operatorPatterns = {
      'BRADESCO': [/BRADESCO\s*SA√öDE/i, /BRADESCO/i],
      'SULAMERICA': [/SULAM√âRICA/i, /SUL\s*AM√âRICA/i, /SULAMERICA/i],
      'UNIMED': [/UNIMED/i],
      'AMIL': [/AMIL/i],
      'PORTO': [/PORTO\s*SEGURO/i]
    };

    for (const [operator, patterns] of Object.entries(operatorPatterns)) {
      if (patterns.some(pattern => pattern.test(text))) {
        return operator;
      }
    }
    return null;
  }
}
```
**O QUE FAZ:**
- **IDENTIFICA** operadora por 2 m√©todos
- **PRIORIZA** detec√ß√£o por c√≥digo ANS (mais precisa)
- **USA** padr√µes de texto como fallback
- **MAPEIA** c√≥digos ANS para nomes de operadoras

---

### **8. üí≥ sulamerica-extractor.ts - EXTRATOR SUL AM√âRICA**
```typescript
// server/services/document-extraction/extractors/sulamerica-extractor.ts
export class SulAmericaExtractor implements IOperatorExtractor {
  
  extractCardNumber(text: string): string | null {
    console.log('üîç Sul Am√©rica: Extraindo n√∫mero da carteirinha...');
    
    const patterns = [
      /\b(8{4,5}[\s]*\d{4}[\s]*\d{4}[\s]*\d{4})\b/,  // 88888 4872 8768 0017
      /\b(8{3,4}\d{13,14})\b/,                        // 88884872876800017
    ];
    
    for (const pattern of patterns) {
      const match = text.match(pattern);
      if (match && match[1]) {
        let numero = match[1].replace(/\s/g, '');
        
        // Validar: 17 d√≠gitos come√ßando com 888/8888
        if (/^8{3,4}\d{13,14}$/.test(numero) && numero.length === 17) {
          console.log('‚úÖ Sul Am√©rica: N√∫mero encontrado:', numero);
          return numero;
        }
      }
    }
    return null;
  }

  extractPlan(text: string): string | null {
    const planPatterns = [
      /(?:PLANO|PRODUTO)[\s:]*([A-Z][A-Z\s]*(?:EXACT|TRADICIONAL|PREMIUM|EXECUTIVO|MASTER)[A-Z\s]*)/i,
      /PLANO[\s:]*([A-Z\s]+)/i
    ];
    
    for (const pattern of planPatterns) {
      const match = text.match(pattern);
      if (match && match[1]) {
        return match[1].trim();
      }
    }
    return null;
  }
}
```
**O QUE FAZ:**
- **ESPECIALIZA** extra√ß√£o para carteirinhas Sul Am√©rica
- **RECONHECE** padr√£o espec√≠fico: 17 d√≠gitos come√ßando com 888
- **EXTRAI** nomes de planos Sul Am√©rica
- **VALIDA** n√∫meros encontrados contra padr√µes conhecidos

---

### **9. üêõ flow-debugger.ts - SISTEMA DE DEBUG**
```typescript
// server/services/document-extraction/utils/flow-debugger.ts
export class FlowDebugger {
  static enter(file: string, functionName: string, data?: any) {
    const timestamp = new Date().toISOString().split('T')[1];
    console.log(`üîµ [${timestamp}] ENTRADA ‚Üí ${file} :: ${functionName}()`);
    this.steps.push({ timestamp, file, function: functionName, action: 'ENTER', data });
  }

  static transition(fromFile: string, fromFunction: string, toFile: string, toFunction: string) {
    const timestamp = new Date().toISOString().split('T')[1];
    console.log(`üîÑ [${timestamp}] TRANSI√á√ÉO ‚Üí ${fromFile}::${fromFunction}() ‚ûú ${toFile}::${toFunction}()`);
  }

  static data(file: string, functionName: string, label: string, data: any) {
    const timestamp = new Date().toISOString().split('T')[1];
    const dataStr = JSON.stringify(data) || 'undefined';
    console.log(`üìä [${timestamp}] DADOS ‚Üí ${file} :: ${functionName}() | ${label}: ${dataStr.substring(0, 150)}`);
  }
}
```
**O QUE FAZ:**
- **RASTREIA** cada passo do processamento
- **REGISTRA** timestamps e dados em cada etapa
- **MOSTRA** transi√ß√µes entre arquivos/fun√ß√µes
- **GERA** logs detalhados para debugging

---

## üîó **FLUXO COMPLETO INTEGRADO**

```
1. UPLOAD
   ‚îî‚îÄ patient-form-dialog.tsx:450
      ‚îî‚îÄ processInsuranceCardWithOCR(file)

2. API REQUEST  
   ‚îî‚îÄ routes.ts:3308
      ‚îî‚îÄ import('./services/document-extraction/index.js')

3. ENTRY POINT
   ‚îî‚îÄ index.ts:processDocument()
      ‚îî‚îÄ new ExtractionOrchestrator()

4. ORCHESTRATOR
   ‚îî‚îÄ extraction-orchestrator.ts:processDocument()
      ‚îú‚îÄ üëÅÔ∏è ocrEngine.extractText() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ "ROSANA ROITMAN SUL AM√âRICA..."
      ‚îú‚îÄ üßπ TextPreprocessor.cleanText() ‚îÄ‚îÄ‚îÄ‚ñ∫ "ROSANA ROITMAN SUL AMERICA..."  
      ‚îú‚îÄ üîç ANSDetector.extractANSCode() ‚îÄ‚îÄ‚îÄ‚ñ∫ "006246"
      ‚îú‚îÄ üè• OperatorDetector.detectOperator()‚ñ∫ "SULAMERICA"
      ‚îî‚îÄ üí≥ sulAmericaExtractor.extract() ‚îÄ‚îÄ‚ñ∫ "88888487287680017"

5. RESPONSE
   ‚îî‚îÄ { success: true, data: { operadora: "SULAMERICA", numeroCarteirinha: "88888487287680017", ... }}

6. FRONTEND FILL
   ‚îî‚îÄ form.setValue('insuranceNumber', result.data.numeroCarteirinha)
```

**RESULTADO:** Carteirinha processada em 516ms com 93.33% de confidence, 3 campos preenchidos automaticamente no formul√°rio.